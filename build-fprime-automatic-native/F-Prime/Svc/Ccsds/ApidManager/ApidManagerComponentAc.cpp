// ======================================================================
// \title  ApidManagerComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for ApidManager component base class
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/ExternalString.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif
#include "Svc/Ccsds/ApidManager/ApidManagerComponentAc.hpp"

namespace Svc {

  namespace Ccsds {

    // ----------------------------------------------------------------------
    // Component initialization
    // ----------------------------------------------------------------------

    void ApidManagerComponentBase ::
      init(FwEnumStoreType instance)
    {
      // Initialize base class
      Fw::PassiveComponentBase::init(instance);

      // Connect input port getApidSeqCountIn
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_getApidSeqCountIn_InputPorts());
        port++
      ) {
        this->m_getApidSeqCountIn_InputPort[port].init();
        this->m_getApidSeqCountIn_InputPort[port].addCallComp(
          this,
          m_p_getApidSeqCountIn_in
        );
        this->m_getApidSeqCountIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_getApidSeqCountIn_InputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_getApidSeqCountIn_InputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect input port validateApidSeqCountIn
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_validateApidSeqCountIn_InputPorts());
        port++
      ) {
        this->m_validateApidSeqCountIn_InputPort[port].init();
        this->m_validateApidSeqCountIn_InputPort[port].addCallComp(
          this,
          m_p_validateApidSeqCountIn_in
        );
        this->m_validateApidSeqCountIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_validateApidSeqCountIn_InputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_validateApidSeqCountIn_InputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect output port logOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_logOut_OutputPorts());
        port++
      ) {
        this->m_logOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_logOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_logOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }

#if FW_ENABLE_TEXT_LOGGING == 1
      // Connect output port logTextOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_logTextOut_OutputPorts());
        port++
      ) {
        this->m_logTextOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_logTextOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_logTextOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }
#endif

      // Connect output port timeCaller
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_timeCaller_OutputPorts());
        port++
      ) {
        this->m_timeCaller_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_timeCaller_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_timeCaller_OutputPort[port].setObjName(portName.toChar());
#endif
      }
    }

    // ----------------------------------------------------------------------
    // Getters for typed input ports
    // ----------------------------------------------------------------------

    Svc::Ccsds::InputApidSequenceCountPort* ApidManagerComponentBase ::
      get_getApidSeqCountIn_InputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_getApidSeqCountIn_InputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return &this->m_getApidSeqCountIn_InputPort[portNum];
    }

    Svc::Ccsds::InputApidSequenceCountPort* ApidManagerComponentBase ::
      get_validateApidSeqCountIn_InputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_validateApidSeqCountIn_InputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return &this->m_validateApidSeqCountIn_InputPort[portNum];
    }

    // ----------------------------------------------------------------------
    // Connect input ports to special output ports
    // ----------------------------------------------------------------------

    void ApidManagerComponentBase ::
      set_logOut_OutputPort(
          FwIndexType portNum,
          Fw::InputLogPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_logOut_OutputPort[portNum].addCallPort(port);
    }

#if FW_ENABLE_TEXT_LOGGING == 1

    void ApidManagerComponentBase ::
      set_logTextOut_OutputPort(
          FwIndexType portNum,
          Fw::InputLogTextPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_logTextOut_OutputPort[portNum].addCallPort(port);
    }

#endif

    void ApidManagerComponentBase ::
      set_timeCaller_OutputPort(
          FwIndexType portNum,
          Fw::InputTimePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_timeCaller_OutputPort[portNum].addCallPort(port);
    }

#if FW_PORT_SERIALIZATION

    // ----------------------------------------------------------------------
    // Connect serial input ports to special output ports
    // ----------------------------------------------------------------------

    void ApidManagerComponentBase ::
      set_logOut_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_logOut_OutputPort[portNum].registerSerialPort(port);
    }

#if FW_ENABLE_TEXT_LOGGING == 1

    void ApidManagerComponentBase ::
      set_logTextOut_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_logTextOut_OutputPort[portNum].registerSerialPort(port);
    }

#endif

    void ApidManagerComponentBase ::
      set_timeCaller_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_timeCaller_OutputPort[portNum].registerSerialPort(port);
    }

#endif

    // ----------------------------------------------------------------------
    // Component construction and destruction
    // ----------------------------------------------------------------------

    ApidManagerComponentBase ::
      ApidManagerComponentBase(const char* compName) :
        Fw::PassiveComponentBase(compName)
    {

    }

    ApidManagerComponentBase ::
      ~ApidManagerComponentBase()
    {

    }

    // ----------------------------------------------------------------------
    // Getters for numbers of typed input ports
    // ----------------------------------------------------------------------

    FwIndexType ApidManagerComponentBase ::
      getNum_getApidSeqCountIn_InputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_getApidSeqCountIn_InputPort));
    }

    FwIndexType ApidManagerComponentBase ::
      getNum_validateApidSeqCountIn_InputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_validateApidSeqCountIn_InputPort));
    }

    // ----------------------------------------------------------------------
    // Getters for numbers of special output ports
    // ----------------------------------------------------------------------

    FwIndexType ApidManagerComponentBase ::
      getNum_logOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_logOut_OutputPort));
    }

#if FW_ENABLE_TEXT_LOGGING == 1

    FwIndexType ApidManagerComponentBase ::
      getNum_logTextOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_logTextOut_OutputPort));
    }

#endif

    FwIndexType ApidManagerComponentBase ::
      getNum_timeCaller_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_timeCaller_OutputPort));
    }

    // ----------------------------------------------------------------------
    // Connection status queries for special output ports
    // ----------------------------------------------------------------------

    bool ApidManagerComponentBase ::
      isConnected_logOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_logOut_OutputPort[portNum].isConnected();
    }

#if FW_ENABLE_TEXT_LOGGING == 1

    bool ApidManagerComponentBase ::
      isConnected_logTextOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_logTextOut_OutputPort[portNum].isConnected();
    }

#endif

    bool ApidManagerComponentBase ::
      isConnected_timeCaller_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_timeCaller_OutputPort[portNum].isConnected();
    }

    // ----------------------------------------------------------------------
    // Port handler base-class functions for typed input ports
    //
    // Call these functions directly to bypass the corresponding ports
    // ----------------------------------------------------------------------

    U16 ApidManagerComponentBase ::
      getApidSeqCountIn_handlerBase(
          FwIndexType portNum,
          const ComCfg::APID& apid,
          U16 sequenceCount
      )
    {
      // Make sure port number is valid
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_getApidSeqCountIn_InputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      U16 retVal;

      // Lock guard mutex before calling
      this->lock();

      // Call handler function
      retVal = this->getApidSeqCountIn_handler(
        portNum,
        apid,
        sequenceCount
      );

      // Unlock guard mutex
      this->unLock();

      return retVal;
    }

    U16 ApidManagerComponentBase ::
      validateApidSeqCountIn_handlerBase(
          FwIndexType portNum,
          const ComCfg::APID& apid,
          U16 sequenceCount
      )
    {
      // Make sure port number is valid
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_validateApidSeqCountIn_InputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      U16 retVal;

      // Lock guard mutex before calling
      this->lock();

      // Call handler function
      retVal = this->validateApidSeqCountIn_handler(
        portNum,
        apid,
        sequenceCount
      );

      // Unlock guard mutex
      this->unLock();

      return retVal;
    }

    // ----------------------------------------------------------------------
    // Event logging functions
    // ----------------------------------------------------------------------

    void ApidManagerComponentBase ::
      log_WARNING_LO_UnexpectedSequenceCount(
          U16 transmitted,
          U16 expected
      ) const
    {
      // Get the time
      Fw::Time _logTime;
      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        this->m_timeCaller_OutputPort[0].invoke(_logTime);
      }

      FwEventIdType _id = static_cast<FwEventIdType>(0);

      _id = this->getIdBase() + EVENTID_UNEXPECTEDSEQUENCECOUNT;

      // Emit the event on the log port
      if (this->m_logOut_OutputPort[0].isConnected()) {
        Fw::LogBuffer _logBuff;
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Serialize the number of arguments
        _status = _logBuff.serializeFrom(static_cast<U8>(2));
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(transmitted);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(expected);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        this->m_logOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_LO,
          _logBuff
        );
      }

      // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
      if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
        const char* _formatString =
          "(%s) %s: Unexpected sequence count received. Packets may have been dropped. Transmitted: %" PRIu16 " | Expected on board: %" PRIu16 "";
#else
        const char* _formatString =
          "%s: Unexpected sequence count received. Packets may have been dropped. Transmitted: %" PRIu16 " | Expected on board: %" PRIu16 "";
#endif

        Fw::TextLogString _logString;
        _logString.format(
          _formatString,
#if FW_OBJECT_NAMES == 1
          this->m_objName.toChar(),
#endif
          "UnexpectedSequenceCount ",
          transmitted,
          expected
        );

        this->m_logTextOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_LO,
          _logString
        );
      }
#endif
    }

    void ApidManagerComponentBase ::
      log_WARNING_HI_ApidTableFull(U16 invalidApidValue) const
    {
      // Get the time
      Fw::Time _logTime;
      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        this->m_timeCaller_OutputPort[0].invoke(_logTime);
      }

      FwEventIdType _id = static_cast<FwEventIdType>(0);

      _id = this->getIdBase() + EVENTID_APIDTABLEFULL;

      // Emit the event on the log port
      if (this->m_logOut_OutputPort[0].isConnected()) {
        Fw::LogBuffer _logBuff;
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Serialize the number of arguments
        _status = _logBuff.serializeFrom(static_cast<U8>(1));
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(invalidApidValue);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        this->m_logOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_HI,
          _logBuff
        );
      }

      // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
      if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
        const char* _formatString =
          "(%s) %s: APID Table is full, cannot generate or check sequence counts for APID: %" PRIu16 "";
#else
        const char* _formatString =
          "%s: APID Table is full, cannot generate or check sequence counts for APID: %" PRIu16 "";
#endif

        Fw::TextLogString _logString;
        _logString.format(
          _formatString,
#if FW_OBJECT_NAMES == 1
          this->m_objName.toChar(),
#endif
          "ApidTableFull ",
          invalidApidValue
        );

        this->m_logTextOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_HI,
          _logString
        );
      }
#endif
    }

    // ----------------------------------------------------------------------
    // Time
    // ----------------------------------------------------------------------

    Fw::Time ApidManagerComponentBase ::
      getTime() const
    {
      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        Fw::Time _time;
        this->m_timeCaller_OutputPort[0].invoke(_time);
        return _time;
      }
      else {
        return Fw::Time(TimeBase::TB_NONE, 0, 0);
      }
    }

    // ----------------------------------------------------------------------
    // Mutex operations for guarded ports
    //
    // You can override these operations to provide more sophisticated
    // synchronization
    // ----------------------------------------------------------------------

    void ApidManagerComponentBase ::
      lock()
    {
      this->m_guardedPortMutex.lock();
    }

    void ApidManagerComponentBase ::
      unLock()
    {
      this->m_guardedPortMutex.unLock();
    }

    // ----------------------------------------------------------------------
    // Calls for messages received on typed input ports
    // ----------------------------------------------------------------------

    U16 ApidManagerComponentBase ::
      m_p_getApidSeqCountIn_in(
          Fw::PassiveComponentBase* callComp,
          FwIndexType portNum,
          const ComCfg::APID& apid,
          U16 sequenceCount
      )
    {
      FW_ASSERT(callComp);
      ApidManagerComponentBase* compPtr = static_cast<ApidManagerComponentBase*>(callComp);
      return compPtr->getApidSeqCountIn_handlerBase(
        portNum,
        apid,
        sequenceCount
      );
    }

    U16 ApidManagerComponentBase ::
      m_p_validateApidSeqCountIn_in(
          Fw::PassiveComponentBase* callComp,
          FwIndexType portNum,
          const ComCfg::APID& apid,
          U16 sequenceCount
      )
    {
      FW_ASSERT(callComp);
      ApidManagerComponentBase* compPtr = static_cast<ApidManagerComponentBase*>(callComp);
      return compPtr->validateApidSeqCountIn_handlerBase(
        portNum,
        apid,
        sequenceCount
      );
    }

  }

}
