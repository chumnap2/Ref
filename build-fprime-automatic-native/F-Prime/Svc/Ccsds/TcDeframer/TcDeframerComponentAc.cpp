// ======================================================================
// \title  TcDeframerComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for TcDeframer component base class
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/ExternalString.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif
#include "Svc/Ccsds/TcDeframer/TcDeframerComponentAc.hpp"

namespace Svc {

  namespace Ccsds {

    // ----------------------------------------------------------------------
    // Component initialization
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      init(FwEnumStoreType instance)
    {
      // Initialize base class
      Fw::PassiveComponentBase::init(instance);

      // Connect input port dataIn
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_dataIn_InputPorts());
        port++
      ) {
        this->m_dataIn_InputPort[port].init();
        this->m_dataIn_InputPort[port].addCallComp(
          this,
          m_p_dataIn_in
        );
        this->m_dataIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_dataIn_InputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_dataIn_InputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect input port dataReturnIn
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_dataReturnIn_InputPorts());
        port++
      ) {
        this->m_dataReturnIn_InputPort[port].init();
        this->m_dataReturnIn_InputPort[port].addCallComp(
          this,
          m_p_dataReturnIn_in
        );
        this->m_dataReturnIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_dataReturnIn_InputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_dataReturnIn_InputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect output port logOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_logOut_OutputPorts());
        port++
      ) {
        this->m_logOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_logOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_logOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }

#if FW_ENABLE_TEXT_LOGGING == 1
      // Connect output port logTextOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_logTextOut_OutputPorts());
        port++
      ) {
        this->m_logTextOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_logTextOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_logTextOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }
#endif

      // Connect output port prmGetOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_prmGetOut_OutputPorts());
        port++
      ) {
        this->m_prmGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_prmGetOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_prmGetOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect output port prmSetOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_prmSetOut_OutputPorts());
        port++
      ) {
        this->m_prmSetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_prmSetOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_prmSetOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect output port timeCaller
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_timeCaller_OutputPorts());
        port++
      ) {
        this->m_timeCaller_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_timeCaller_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_timeCaller_OutputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect output port tlmOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_tlmOut_OutputPorts());
        port++
      ) {
        this->m_tlmOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_tlmOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_tlmOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect output port dataOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_dataOut_OutputPorts());
        port++
      ) {
        this->m_dataOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_dataOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_dataOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }

      // Connect output port dataReturnOut
      for (
        FwIndexType port = 0;
        port < static_cast<FwIndexType>(this->getNum_dataReturnOut_OutputPorts());
        port++
      ) {
        this->m_dataReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
        Fw::ObjectName portName;
        portName.format(
          "%s_dataReturnOut_OutputPort[%" PRI_FwIndexType "]",
          this->m_objName.toChar(),
          port
        );
        this->m_dataReturnOut_OutputPort[port].setObjName(portName.toChar());
#endif
      }
    }

    // ----------------------------------------------------------------------
    // Getters for typed input ports
    // ----------------------------------------------------------------------

    Svc::InputComDataWithContextPort* TcDeframerComponentBase ::
      get_dataIn_InputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataIn_InputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return &this->m_dataIn_InputPort[portNum];
    }

    Svc::InputComDataWithContextPort* TcDeframerComponentBase ::
      get_dataReturnIn_InputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataReturnIn_InputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return &this->m_dataReturnIn_InputPort[portNum];
    }

    // ----------------------------------------------------------------------
    // Connect input ports to special output ports
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      set_logOut_OutputPort(
          FwIndexType portNum,
          Fw::InputLogPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_logOut_OutputPort[portNum].addCallPort(port);
    }

#if FW_ENABLE_TEXT_LOGGING == 1

    void TcDeframerComponentBase ::
      set_logTextOut_OutputPort(
          FwIndexType portNum,
          Fw::InputLogTextPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_logTextOut_OutputPort[portNum].addCallPort(port);
    }

#endif

    void TcDeframerComponentBase ::
      set_prmGetOut_OutputPort(
          FwIndexType portNum,
          Fw::InputPrmGetPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_prmGetOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_prmGetOut_OutputPort[portNum].addCallPort(port);
    }

    void TcDeframerComponentBase ::
      set_prmSetOut_OutputPort(
          FwIndexType portNum,
          Fw::InputPrmSetPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_prmSetOut_OutputPort[portNum].addCallPort(port);
    }

    void TcDeframerComponentBase ::
      set_timeCaller_OutputPort(
          FwIndexType portNum,
          Fw::InputTimePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_timeCaller_OutputPort[portNum].addCallPort(port);
    }

    void TcDeframerComponentBase ::
      set_tlmOut_OutputPort(
          FwIndexType portNum,
          Fw::InputTlmPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_tlmOut_OutputPort[portNum].addCallPort(port);
    }

    // ----------------------------------------------------------------------
    // Connect typed input ports to typed output ports
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      set_dataOut_OutputPort(
          FwIndexType portNum,
          Svc::InputComDataWithContextPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_dataOut_OutputPort[portNum].addCallPort(port);
    }

    void TcDeframerComponentBase ::
      set_dataReturnOut_OutputPort(
          FwIndexType portNum,
          Svc::InputComDataWithContextPort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataReturnOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_dataReturnOut_OutputPort[portNum].addCallPort(port);
    }

#if FW_PORT_SERIALIZATION

    // ----------------------------------------------------------------------
    // Connect serial input ports to special output ports
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      set_logOut_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_logOut_OutputPort[portNum].registerSerialPort(port);
    }

#if FW_ENABLE_TEXT_LOGGING == 1

    void TcDeframerComponentBase ::
      set_logTextOut_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_logTextOut_OutputPort[portNum].registerSerialPort(port);
    }

#endif

    void TcDeframerComponentBase ::
      set_prmSetOut_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_prmSetOut_OutputPort[portNum].registerSerialPort(port);
    }

    void TcDeframerComponentBase ::
      set_timeCaller_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_timeCaller_OutputPort[portNum].registerSerialPort(port);
    }

    void TcDeframerComponentBase ::
      set_tlmOut_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
    }

#endif

#if FW_PORT_SERIALIZATION

    // ----------------------------------------------------------------------
    // Connect serial input ports to typed output ports
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      set_dataOut_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_dataOut_OutputPort[portNum].registerSerialPort(port);
    }

    void TcDeframerComponentBase ::
      set_dataReturnOut_OutputPort(
          FwIndexType portNum,
          Fw::InputSerializePort* port
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataReturnOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      this->m_dataReturnOut_OutputPort[portNum].registerSerialPort(port);
    }

#endif

    // ----------------------------------------------------------------------
    // Component construction and destruction
    // ----------------------------------------------------------------------

    TcDeframerComponentBase ::
      TcDeframerComponentBase(const char* compName) :
        Fw::PassiveComponentBase(compName)
    {

    }

    TcDeframerComponentBase ::
      ~TcDeframerComponentBase()
    {

    }

    // ----------------------------------------------------------------------
    // Getters for numbers of typed input ports
    // ----------------------------------------------------------------------

    FwIndexType TcDeframerComponentBase ::
      getNum_dataIn_InputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_dataIn_InputPort));
    }

    FwIndexType TcDeframerComponentBase ::
      getNum_dataReturnIn_InputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_dataReturnIn_InputPort));
    }

    // ----------------------------------------------------------------------
    // Getters for numbers of special output ports
    // ----------------------------------------------------------------------

    FwIndexType TcDeframerComponentBase ::
      getNum_logOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_logOut_OutputPort));
    }

#if FW_ENABLE_TEXT_LOGGING == 1

    FwIndexType TcDeframerComponentBase ::
      getNum_logTextOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_logTextOut_OutputPort));
    }

#endif

    FwIndexType TcDeframerComponentBase ::
      getNum_prmGetOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_prmGetOut_OutputPort));
    }

    FwIndexType TcDeframerComponentBase ::
      getNum_prmSetOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_prmSetOut_OutputPort));
    }

    FwIndexType TcDeframerComponentBase ::
      getNum_timeCaller_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_timeCaller_OutputPort));
    }

    FwIndexType TcDeframerComponentBase ::
      getNum_tlmOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_tlmOut_OutputPort));
    }

    // ----------------------------------------------------------------------
    // Getters for numbers of typed output ports
    // ----------------------------------------------------------------------

    FwIndexType TcDeframerComponentBase ::
      getNum_dataOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_dataOut_OutputPort));
    }

    FwIndexType TcDeframerComponentBase ::
      getNum_dataReturnOut_OutputPorts() const
    {
      return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_dataReturnOut_OutputPort));
    }

    // ----------------------------------------------------------------------
    // Connection status queries for special output ports
    // ----------------------------------------------------------------------

    bool TcDeframerComponentBase ::
      isConnected_logOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_logOut_OutputPort[portNum].isConnected();
    }

#if FW_ENABLE_TEXT_LOGGING == 1

    bool TcDeframerComponentBase ::
      isConnected_logTextOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_logTextOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_logTextOut_OutputPort[portNum].isConnected();
    }

#endif

    bool TcDeframerComponentBase ::
      isConnected_prmGetOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_prmGetOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_prmGetOut_OutputPort[portNum].isConnected();
    }

    bool TcDeframerComponentBase ::
      isConnected_prmSetOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_prmSetOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_prmSetOut_OutputPort[portNum].isConnected();
    }

    bool TcDeframerComponentBase ::
      isConnected_timeCaller_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_timeCaller_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_timeCaller_OutputPort[portNum].isConnected();
    }

    bool TcDeframerComponentBase ::
      isConnected_tlmOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_tlmOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_tlmOut_OutputPort[portNum].isConnected();
    }

    // ----------------------------------------------------------------------
    // Connection status queries for typed output ports
    // ----------------------------------------------------------------------

    bool TcDeframerComponentBase ::
      isConnected_dataOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_dataOut_OutputPort[portNum].isConnected();
    }

    bool TcDeframerComponentBase ::
      isConnected_dataReturnOut_OutputPort(FwIndexType portNum)
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataReturnOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      return this->m_dataReturnOut_OutputPort[portNum].isConnected();
    }

    // ----------------------------------------------------------------------
    // Port handler base-class functions for typed input ports
    //
    // Call these functions directly to bypass the corresponding ports
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      dataIn_handlerBase(
          FwIndexType portNum,
          Fw::Buffer& data,
          const ComCfg::FrameContext& context
      )
    {
      // Make sure port number is valid
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataIn_InputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      // Lock guard mutex before calling
      this->lock();

      // Call handler function
      this->dataIn_handler(
        portNum,
        data,
        context
      );

      // Unlock guard mutex
      this->unLock();
    }

    void TcDeframerComponentBase ::
      dataReturnIn_handlerBase(
          FwIndexType portNum,
          Fw::Buffer& data,
          const ComCfg::FrameContext& context
      )
    {
      // Make sure port number is valid
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataReturnIn_InputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      // Call handler function
      this->dataReturnIn_handler(
        portNum,
        data,
        context
      );
    }

    // ----------------------------------------------------------------------
    // Invocation functions for typed output ports
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      dataOut_out(
          FwIndexType portNum,
          Fw::Buffer& data,
          const ComCfg::FrameContext& context
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      FW_ASSERT(
        this->m_dataOut_OutputPort[portNum].isConnected(),
        static_cast<FwAssertArgType>(portNum)
      );
      this->m_dataOut_OutputPort[portNum].invoke(
        data,
        context
      );
    }

    void TcDeframerComponentBase ::
      dataReturnOut_out(
          FwIndexType portNum,
          Fw::Buffer& data,
          const ComCfg::FrameContext& context
      )
    {
      FW_ASSERT(
        (0 <= portNum) && (portNum < this->getNum_dataReturnOut_OutputPorts()),
        static_cast<FwAssertArgType>(portNum)
      );

      FW_ASSERT(
        this->m_dataReturnOut_OutputPort[portNum].isConnected(),
        static_cast<FwAssertArgType>(portNum)
      );
      this->m_dataReturnOut_OutputPort[portNum].invoke(
        data,
        context
      );
    }

    // ----------------------------------------------------------------------
    // Event logging functions
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      log_WARNING_LO_InvalidSpacecraftId(
          U16 transmitted,
          U16 configured
      ) const
    {
      // Get the time
      Fw::Time _logTime;
      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        this->m_timeCaller_OutputPort[0].invoke(_logTime);
      }

      FwEventIdType _id = static_cast<FwEventIdType>(0);

      _id = this->getIdBase() + EVENTID_INVALIDSPACECRAFTID;

      // Emit the event on the log port
      if (this->m_logOut_OutputPort[0].isConnected()) {
        Fw::LogBuffer _logBuff;
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Serialize the number of arguments
        _status = _logBuff.serializeFrom(static_cast<U8>(2));
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(transmitted);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(configured);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        this->m_logOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_LO,
          _logBuff
        );
      }

      // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
      if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
        const char* _formatString =
          "(%s) %s: Invalid Spacecraft ID Received. Received: %" PRIu16 " | Deframer configured with: %" PRIu16 "";
#else
        const char* _formatString =
          "%s: Invalid Spacecraft ID Received. Received: %" PRIu16 " | Deframer configured with: %" PRIu16 "";
#endif

        Fw::TextLogString _logString;
        _logString.format(
          _formatString,
#if FW_OBJECT_NAMES == 1
          this->m_objName.toChar(),
#endif
          "InvalidSpacecraftId ",
          transmitted,
          configured
        );

        this->m_logTextOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_LO,
          _logString
        );
      }
#endif
    }

    void TcDeframerComponentBase ::
      log_WARNING_HI_InvalidFrameLength(
          U16 transmitted,
          FwSizeType actual
      ) const
    {
      // Get the time
      Fw::Time _logTime;
      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        this->m_timeCaller_OutputPort[0].invoke(_logTime);
      }

      FwEventIdType _id = static_cast<FwEventIdType>(0);

      _id = this->getIdBase() + EVENTID_INVALIDFRAMELENGTH;

      // Emit the event on the log port
      if (this->m_logOut_OutputPort[0].isConnected()) {
        Fw::LogBuffer _logBuff;
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Serialize the number of arguments
        _status = _logBuff.serializeFrom(static_cast<U8>(2));
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(transmitted);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(FwSizeType))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(actual);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        this->m_logOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_HI,
          _logBuff
        );
      }

      // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
      if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
        const char* _formatString =
          "(%s) %s: Not enough data received. Header length specified: %" PRIu16 " | Received data length: %" PRIu64 "";
#else
        const char* _formatString =
          "%s: Not enough data received. Header length specified: %" PRIu16 " | Received data length: %" PRIu64 "";
#endif

        Fw::TextLogString _logString;
        _logString.format(
          _formatString,
#if FW_OBJECT_NAMES == 1
          this->m_objName.toChar(),
#endif
          "InvalidFrameLength ",
          transmitted,
          actual
        );

        this->m_logTextOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_HI,
          _logString
        );
      }
#endif
    }

    void TcDeframerComponentBase ::
      log_ACTIVITY_LO_InvalidVcId(
          U16 transmitted,
          U16 configured
      ) const
    {
      // Get the time
      Fw::Time _logTime;
      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        this->m_timeCaller_OutputPort[0].invoke(_logTime);
      }

      FwEventIdType _id = static_cast<FwEventIdType>(0);

      _id = this->getIdBase() + EVENTID_INVALIDVCID;

      // Emit the event on the log port
      if (this->m_logOut_OutputPort[0].isConnected()) {
        Fw::LogBuffer _logBuff;
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Serialize the number of arguments
        _status = _logBuff.serializeFrom(static_cast<U8>(2));
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(transmitted);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(configured);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        this->m_logOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::ACTIVITY_LO,
          _logBuff
        );
      }

      // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
      if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
        const char* _formatString =
          "(%s) %s: Invalid Virtual Channel ID Received. Header token specified: %" PRIu16 " | Deframer configured with: %" PRIu16 "";
#else
        const char* _formatString =
          "%s: Invalid Virtual Channel ID Received. Header token specified: %" PRIu16 " | Deframer configured with: %" PRIu16 "";
#endif

        Fw::TextLogString _logString;
        _logString.format(
          _formatString,
#if FW_OBJECT_NAMES == 1
          this->m_objName.toChar(),
#endif
          "InvalidVcId ",
          transmitted,
          configured
        );

        this->m_logTextOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::ACTIVITY_LO,
          _logString
        );
      }
#endif
    }

    void TcDeframerComponentBase ::
      log_WARNING_HI_InvalidCrc(
          U16 transmitted,
          U16 computed
      ) const
    {
      // Get the time
      Fw::Time _logTime;
      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        this->m_timeCaller_OutputPort[0].invoke(_logTime);
      }

      FwEventIdType _id = static_cast<FwEventIdType>(0);

      _id = this->getIdBase() + EVENTID_INVALIDCRC;

      // Emit the event on the log port
      if (this->m_logOut_OutputPort[0].isConnected()) {
        Fw::LogBuffer _logBuff;
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Serialize the number of arguments
        _status = _logBuff.serializeFrom(static_cast<U8>(2));
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(transmitted);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

#if FW_AMPCS_COMPATIBLE
        // Serialize the argument size
        _status = _logBuff.serializeFrom(
          static_cast<U8>(sizeof(U16))
        );
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
#endif
        _status = _logBuff.serializeFrom(computed);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        this->m_logOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_HI,
          _logBuff
        );
      }

      // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
      if (this->m_logTextOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
        const char* _formatString =
          "(%s) %s: Invalid checksum received. Trailer specified: %" PRIu16 " | Computed on board: %" PRIu16 "";
#else
        const char* _formatString =
          "%s: Invalid checksum received. Trailer specified: %" PRIu16 " | Computed on board: %" PRIu16 "";
#endif

        Fw::TextLogString _logString;
        _logString.format(
          _formatString,
#if FW_OBJECT_NAMES == 1
          this->m_objName.toChar(),
#endif
          "InvalidCrc ",
          transmitted,
          computed
        );

        this->m_logTextOut_OutputPort[0].invoke(
          _id,
          _logTime,
          Fw::LogSeverity::WARNING_HI,
          _logString
        );
      }
#endif
    }

    // ----------------------------------------------------------------------
    // Time
    // ----------------------------------------------------------------------

    Fw::Time TcDeframerComponentBase ::
      getTime() const
    {
      if (this->m_timeCaller_OutputPort[0].isConnected()) {
        Fw::Time _time;
        this->m_timeCaller_OutputPort[0].invoke(_time);
        return _time;
      }
      else {
        return Fw::Time(TimeBase::TB_NONE, 0, 0);
      }
    }

    // ----------------------------------------------------------------------
    // Mutex operations for guarded ports
    //
    // You can override these operations to provide more sophisticated
    // synchronization
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      lock()
    {
      this->m_guardedPortMutex.lock();
    }

    void TcDeframerComponentBase ::
      unLock()
    {
      this->m_guardedPortMutex.unLock();
    }

    // ----------------------------------------------------------------------
    // Calls for messages received on typed input ports
    // ----------------------------------------------------------------------

    void TcDeframerComponentBase ::
      m_p_dataIn_in(
          Fw::PassiveComponentBase* callComp,
          FwIndexType portNum,
          Fw::Buffer& data,
          const ComCfg::FrameContext& context
      )
    {
      FW_ASSERT(callComp);
      TcDeframerComponentBase* compPtr = static_cast<TcDeframerComponentBase*>(callComp);
      compPtr->dataIn_handlerBase(
        portNum,
        data,
        context
      );
    }

    void TcDeframerComponentBase ::
      m_p_dataReturnIn_in(
          Fw::PassiveComponentBase* callComp,
          FwIndexType portNum,
          Fw::Buffer& data,
          const ComCfg::FrameContext& context
      )
    {
      FW_ASSERT(callComp);
      TcDeframerComponentBase* compPtr = static_cast<TcDeframerComponentBase*>(callComp);
      compPtr->dataReturnIn_handlerBase(
        portNum,
        data,
        context
      );
    }

  }

}
