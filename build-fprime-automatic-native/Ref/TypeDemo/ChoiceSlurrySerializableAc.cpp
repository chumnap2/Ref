// ======================================================================
// \title  ChoiceSlurrySerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for ChoiceSlurry struct
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Ref/TypeDemo/ChoiceSlurrySerializableAc.hpp"

namespace Ref {

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  ChoiceSlurry ::
    ChoiceSlurry() :
      Serializable(),
      m_tooManyChoices(Ref::TooManyChoices(Ref::ManyChoices(Ref::Choice::ONE, Ref::Choice::ONE), Ref::ManyChoices(Ref::Choice::ONE, Ref::Choice::ONE))),
      m_separateChoice(Ref::Choice::ONE),
      m_choicePair(Ref::Choice::ONE, Ref::Choice::ONE)
  {
    for (FwSizeType i = 0; i < 2; i++) {
      this->m_choiceAsMemberArray[i] = 0;
    }
  }

  ChoiceSlurry ::
    ChoiceSlurry(
        const Ref::TooManyChoices& tooManyChoices,
        Ref::Choice::T separateChoice,
        const Ref::ChoicePair& choicePair,
        const Type_of_choiceAsMemberArray& choiceAsMemberArray
    ) :
      Serializable(),
      m_tooManyChoices(tooManyChoices),
      m_separateChoice(separateChoice),
      m_choicePair(choicePair)
  {
    for (FwSizeType i = 0; i < 2; i++) {
      this->m_choiceAsMemberArray[i] = choiceAsMemberArray[i];
    }
  }

  ChoiceSlurry ::
    ChoiceSlurry(const ChoiceSlurry& obj) :
      Serializable(),
      m_tooManyChoices(obj.m_tooManyChoices),
      m_separateChoice(obj.m_separateChoice),
      m_choicePair(obj.m_choicePair)
  {
    for (FwSizeType i = 0; i < 2; i++) {
      this->m_choiceAsMemberArray[i] = obj.m_choiceAsMemberArray[i];
    }
  }

  ChoiceSlurry ::
    ChoiceSlurry(
        const Ref::TooManyChoices& tooManyChoices,
        Ref::Choice::T separateChoice,
        const Ref::ChoicePair& choicePair,
        U8 choiceAsMemberArray
    ) :
      Serializable(),
      m_tooManyChoices(tooManyChoices),
      m_separateChoice(separateChoice),
      m_choicePair(choicePair)
  {
    for (FwSizeType i = 0; i < 2; i++) {
      this->m_choiceAsMemberArray[i] = choiceAsMemberArray;
    }
  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  ChoiceSlurry& ChoiceSlurry ::
    operator=(const ChoiceSlurry& obj)
  {
    if (this == &obj) {
      return *this;
    }

    set(obj.m_tooManyChoices, obj.m_separateChoice, obj.m_choicePair, obj.m_choiceAsMemberArray);
    return *this;
  }

  bool ChoiceSlurry ::
    operator==(const ChoiceSlurry& obj) const
  {
    if (this == &obj) { return true; }

    // Compare non-array members
    if (!(
      (this->m_tooManyChoices == obj.m_tooManyChoices) &&
      (this->m_separateChoice == obj.m_separateChoice) &&
      (this->m_choicePair == obj.m_choicePair)
    )) {
      return false;
    }

    // Compare array members
    for (FwSizeType i = 0; i < 2; i++) {
      if (!(this->m_choiceAsMemberArray[i] == obj.m_choiceAsMemberArray[i])) {
        return false;
      }
    }

    return true;
  }

  bool ChoiceSlurry ::
    operator!=(const ChoiceSlurry& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const ChoiceSlurry& obj) {
    Fw::String s;
    obj.toString(s);
    os << s.toChar();
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus ChoiceSlurry ::
    serializeTo(Fw::SerializeBufferBase& buffer) const
  {
    Fw::SerializeStatus status;

    status = buffer.serializeFrom(this->m_tooManyChoices);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_separateChoice);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serializeFrom(this->m_choicePair);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    for (FwSizeType i = 0; i < 2; i++) {
      status = buffer.serializeFrom(this->m_choiceAsMemberArray[i]);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
    }

    return status;
  }

  Fw::SerializeStatus ChoiceSlurry ::
    deserializeFrom(Fw::SerializeBufferBase& buffer)
  {
    Fw::SerializeStatus status;

    status = buffer.deserializeTo(this->m_tooManyChoices);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_separateChoice);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserializeTo(this->m_choicePair);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    for (FwSizeType i = 0; i < 2; i++) {
      status = buffer.deserializeTo(this->m_choiceAsMemberArray[i]);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
    }

    return status;
  }

  FwSizeType ChoiceSlurry ::
    serializedSize() const
  {
    FwSizeType size = 0;
    size += this->m_tooManyChoices.serializedSize();
    size += Ref::Choice::SERIALIZED_SIZE;
    size += this->m_choicePair.serializedSize();
    size += sizeof(U8) * 2;
    return size;
  }

#if FW_SERIALIZABLE_TO_STRING

  void ChoiceSlurry ::
    toString(Fw::StringBase& sb) const
  {
    Fw::String tmp;
    sb = "( ";

    // Format tooManyChoices
    sb += "tooManyChoices = ";
    this->m_tooManyChoices.toString(tmp);
    sb += tmp;
    sb += ", ";

    // Format separateChoice
    sb += "separateChoice = ";
    this->m_separateChoice.toString(tmp);
    sb += tmp;
    sb += ", ";

    // Format choicePair
    sb += "choicePair = ";
    this->m_choicePair.toString(tmp);
    sb += tmp;
    sb += ", ";

    // Format choiceAsMemberArray
    sb += "choiceAsMemberArray = ";
    sb += "[ ";
    for (FwSizeType i = 0; i < 2; i++) {
      tmp.format("%" PRIu8 "", this->m_choiceAsMemberArray[i]);
      if (i > 0) {
        sb += ", ";
      }
      sb += tmp;
    }
    sb += " ]";
    sb += " )";
  }

#endif

  // ----------------------------------------------------------------------
  // Setter functions
  // ----------------------------------------------------------------------

  void ChoiceSlurry ::
    set(
        const Ref::TooManyChoices& tooManyChoices,
        Ref::Choice::T separateChoice,
        const Ref::ChoicePair& choicePair,
        const Type_of_choiceAsMemberArray& choiceAsMemberArray
    )
  {
    this->m_tooManyChoices = tooManyChoices;
    this->m_separateChoice = separateChoice;
    this->m_choicePair = choicePair;

    for (FwSizeType i = 0; i < 2; i++) {
      this->m_choiceAsMemberArray[i] = choiceAsMemberArray[i];
    }
  }

  void ChoiceSlurry ::
    set_tooManyChoices(const Ref::TooManyChoices& tooManyChoices)
  {
    this->m_tooManyChoices = tooManyChoices;
  }

  void ChoiceSlurry ::
    set_separateChoice(Ref::Choice::T separateChoice)
  {
    this->m_separateChoice = separateChoice;
  }

  void ChoiceSlurry ::
    set_choicePair(const Ref::ChoicePair& choicePair)
  {
    this->m_choicePair = choicePair;
  }

  void ChoiceSlurry ::
    set_choiceAsMemberArray(const Type_of_choiceAsMemberArray& choiceAsMemberArray)
  {
    for (FwSizeType i = 0; i < 2; i++) {
      this->m_choiceAsMemberArray[i] = choiceAsMemberArray[i];
    }
  }

}
